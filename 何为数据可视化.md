## 何为数据可视化

#### 概述：所谓数据可视化就是把数据转换为图形的方式展示

### 数据可视化方案

![image](https://user-images.githubusercontent.com/37037802/145366081-559c1ff5-a063-41b3-af6a-0abe111706fe.png)

由上图可知：
- 浏览器底层存在着不同的绘图引擎，例如Skia（由Android和Chrome平台提供的2D绘图引擎）和OpenGL（开放的2D和3D的图形渲染库），OpenGL的功能相对较为强大些，但无论哪种引擎都对canvas、svg、webgl等等脚本开放了绘图的能力。
- 浏览器上一层是canvas、svg、webgl等等脚本。
- canvas、svg、webgl等等脚本的上一层是highcharts、Echarts、AntV、zrender（canvas）、D3（操作svg，类似JQ）、threejs（配合webgl使用）等图形绘制库，这些库只是对canvas、svg、webgl等等脚本api进行了封装，使用起来更方便。

### Canvas高清绘制

背景：在高分屏下，canvas绘制线条、图形、图片会产生模糊问题。产生这样的问题是因为与设备的 window.devicePixelRatio（物理像素和设备独立像素的比例，简称DPI） 属性有关。例如设备window.devicePixelRatio值为1.5，就表示如果在css里从左到右有100物理像素点，但是到了DPI值为1.5的设备下它会用150个物理像素点去展示这100个像素点，那这样可以想象下，我才给了它100个像素，但它却放在了150个像素格里，因此我们看到的内容就被放大和出现模糊了。

ps：像素图（canvas）与分辨率有关出现这情况，矢量图（svg）不会出现这情况。

解决方法：

```
  /* 
    01 放大 canvas 
    02 再在 css 里将宽高设置为原来的大小 
    03 考虑到内容的缩放，因此也需将 ctx 缩放
  */
  const canvas = document.getElementById('canvas')
  const ctx = canvas.getContext('2d')

  const getPixelRatio = (context) => {
    return window.devicePixelRatio || 1
  }
  
  const ratio = getPixelRatio()
  const oldWidth = canvas.width
  const oldHeight = canvas.height

  canvas.width = canvas.width * ratio
  canvas.height = canvas.height * ratio

  canvas.style.width = oldWidth + 'px'
  canvas.style.height = oldHeight + 'px'

  ctx.scale(ratio, ratio)
  
```

ps：style width决定在浏览器的大小表现。canvas html width决定canvas里面有多少个像素。也就是，如果你想要一个2048*2048的画布，那么你要设置canvas的html width和height为2048。但是浏览器放不下这么大。咋办？这时候设置画布的style.width和style.height为800。就搞定了。

### Canvas绘制直角坐标系

```
  // 提前设置相关属性
  const ht = canvas.clientHeight
  const wd = canvas.clientWidth
  const pad = 20
  const bottomPad = 20
  const step = 100

  const drawAxis = (options) => {
    const { ht, wd, pad, bottomPad, step, ctx } = options
    // 绘制坐标轴
    ctx.beginPath()
    ctx.lineWidth = 2
    ctx.strokeStyle = 'lightblue'
    ctx.moveTo(pad, pad)
    ctx.lineTo(pad, ht - bottomPad)
    ctx.lineTo(wd - pad, ht - bottomPad)
    ctx.stroke()
    ctx.closePath()

    // 绘制 X 轴方向刻度
    ctx.beginPath()
    ctx.lineWidth = 1
    ctx.strokeStyle = '#666'
    for (let i = 1; i < Math.floor(wd / step); i++) {
      ctx.moveTo(pad + i * step, ht - bottomPad)
      ctx.lineTo(pad + i * step, ht - bottomPad - 10)
    }
    ctx.stroke()
    ctx.closePath()


    // 绘制 Y 轴方向刻度
    ctx.beginPath()
    ctx.lineWidth = 1
    ctx.strokeStyle = '#666'
    for (let i = 1; i < Math.floor(ht / step); i++) {
      ctx.moveTo(pad, (ht - bottomPad) - (i * step))
      ctx.lineTo(pad + 10, (ht - bottomPad) - (i * step))
    }
    ctx.stroke()
    ctx.closePath()
  }
  
  drawAxis({
    ht: ht,
    wd: wd,
    pad: pad,
    bottomPad: bottomPad,
    step: step,
    ctx: ctx
  })
```

### Canvas绘制直方图

```
  /* 
    矩形填充  context.fillRect(x,y,width,height) 
    x: 矩形左上角的 x 坐标
    y: 矩形左上角的 y 坐标
    width: 矩形的宽度，以像素计
    height: 矩形的高度，以像素计
  */
  // ctx.beginPath()
  // ctx.fillStyle = 'skyblue'
  // ctx.fillRect(410, 310, 300, 200) 
  // ctx.closePath()
  
    const rectWd = 40; //直方图宽
    // 绘制直方图
    ctx.beginPath()
    for (var i = 1; i < Math.floor(wd / step); i++) {
      const height = Math.random() * 300 + 50
      ctx.fillStyle = '#' + parseInt(Math.random() * 0xFFFFFF).toString(16)
      ctx.fillRect(pad + (i * step) - Math.floor(rectWd / 2), ht - bottomPad - height, rectWd, height)
    }
    ctx.closePath()
```

### Canvas绘制饼状图
```
/* 
  创建弧/曲线（用于创建圆或部分圆)  context.arc(x,y,r,sAngle,eAngle,counterclockwise);
  x: 圆的中心的 x 坐标
  y: 圆的中心的 y 坐标
  r: 圆的半径
  sAngle: 起始角，以弧度计。（弧的圆形的三点钟位置是 0 度）
  eAngle: 结束角，以弧度计
  counterclockwise: 可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。
*/

  

  //ctx.beginPath()
  //ctx.fillStyle = '#5C1918'
  //ctx.moveTo(400, 300)
  //ctx.arc(400, 300, 100, -Math.PI / 2, -Math.PI / 4)
  //ctx.fill()
  //ctx.closePath()
  
  const data = [0.2, 0.3, 0.5];
  let start = 0;
  let end = 0;
  for (let i = 0; i < data.length; i++){
    end = data[i] + end;
    ctx.beginPath()
    ctx.fillStyle = '#' + parseInt(Math.random() * 0xFFFFFF).toString(16)
    ctx.moveTo(400, 300)
    ctx.arc(400, 300, 100, 2 * Math.PI * start, 2 * Math.PI * end)
    ctx.fill()
    ctx.closePath()

    start = end;
  }
```

### Canvas绘制折线图

...待更新

### 动画函数
```
    this.canvas = document.getElementById('canvas')
    this.ctx = canvas.getContext('2d')

    function myAnimation(param) {
      let current = 0
      let looped
      const ctx = this.ctx
      const _canvas = this.canvas
      const callback = param.render
      const successCb = param.success;
      (function looping() {
        looped = requestAnimationFrame(looping)
        if (current < param.percent) {
          ctx.clearRect(0, 0, _canvas.width, _canvas.height)
          current = current + 4 > param.percent
            ? param.percent
            : current + 4
          callback(current)
        } else {
          window.cancelAnimationFrame(looping)
          looped = null
          successCb && successCb()
        }
      })()
    }

    myAnimation.call(this, {
      percent: 100,
      render: (current) => {
        console.log(current)
      }
    })
```

### SVG绘制图形与D3.JS

svg是矢量图（矢量图是由多个数学公式绘制而成）

```
  <svg width="1000" height="600">
    <!-- 01 绘制矩形 -->
    <!-- <rect x="40" y="40" width="300" height="200" style="fill:orangered; stroke: pink; stroke-width: 4"></rect> -->

    <!-- 02 绘制圆角矩形 -->
    <!-- <rect x="40" y="40" width="300" rx="20" ry="20" height="200" style="fill:orangered; stroke: pink; stroke-width: 4">
    </rect> -->

    <!-- 03 绘制圆形 -->
    <!-- <circle cx="200" cy="200" r="100" style="fill: darkblue"></circle> -->

    <!-- 04 椭圆 -->
    <!-- <ellipse cx="200" cy="200" rx="80" ry="40" style="fill: seagreen"></ellipse> -->

    <!-- 05 绘制线条 -->
    <!-- <line x1="100" y1="40" x2="500" y2="60" style="stroke:#333; stroke-width: 4"></line> -->

    <!-- 06 绘制多边形 -->
    <polygon points="200, 40, 400, 50, 100, 50" style="fill: lightblue; stroke-width: 2; stroke: red"
      transform="translate(100, 100)"></polygon>

    <!-- 07 绘制文字 -->
    <text x="200" y="200" style="fill: orange; font-size: 40" textLength="200">拉勾教育</text>

  </svg>
```

一般情况下,我们会配合D3.js去操作svg，D3.js类似JQ一样是链式调用操作
```
    // 01 d3 获取元素
    console.log(d3.select('#box'))
    console.log(d3.select('#box p'))
    console.log(d3.selectAll('#box p'))
    console.log(d3.selectAll('div'))

    // 02 获取元素属性
    console.log(+d3.select('rect').attr('width') === 300)

    // 03 设置属性
    // d3.select('rect')
    //   .attr('fill', 'seagreen')
    //   .attr('transform', 'translate(100, 100)')

    // 04 添加删除元素
    d3.select('svg').append('rect')
      .attr('x', 100)
      .attr('y', '200')
      .attr('width', '200')
      .attr('height', '100')
      .attr('fill', 'lightblue')

    d3.select('svg').append('text')
      .attr('x', 100)
      .attr('y', 260)
      .attr('fill', 'red')
      .attr('font-size', 20)
      .attr('textLength', 200)
      .text('拉勾教育')

    // 05 删除元素
    d3.selectAll('rect').remove()
```






