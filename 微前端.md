## 微前端

### 什么是微前端

微前端是一种软件架构，可以将前端应用拆解成一些更小的能够独立开发部署的微型应用，然后再将这些微应用进行组合使其成为整体应用的架构模式。

微前端架构类似于组件架构，但不同的是，组件不能独立构建和发布，但是微前端中的应用是可以的。

微前端架构与框架无关，每个微应用都可以使用不同的框架。

![image](https://user-images.githubusercontent.com/37037802/133610665-56b78fcf-3bf3-4065-9b5e-1244f3f90917.png)


### 微前端的价值

#### 1.增量迁移

迁移是一项非常耗时且艰难的任务，比如有一个管理系统使用 AngularJS 开发维护已经有三年时间，但是随时间的推移和团队成员的变更，无论从开发成本还是用人需求上，AngularJS 已经不能满足要求，于是团队想要新技术栈，想在其他框架中实现新的需求，但是现有项目怎么办？直接迁移是不可能的，在新的框架中完全重写也不太现实。

使用微前端架构就可以解决问题，在保留原有项目的同时，可以完全使用新的框架开发新的需求，然后再使用微前端架构将旧的项目和新的项目进行整合。这样既可以使产品得到更好的用户体验，也可以使团队成员在技术上得到进步，产品开发成本也降到的最低。

#### 2.独立发布

在目前的单页应用架构中，使用组件构建用户界面，应用中的每个组件或功能开发完成或者bug修复完成后，每次都需要对整个产品重新进行构建和发布，任务耗时操作上也比较繁琐。在使用了微前端架构后，可以将不能的功能模块拆分成独立的应用，此时功能模块就可以单独构建单独发布了，构建时间也会变得非常快，应用发布后不需要更改其他内容应用就会自动更新，这意味着你可以进行频繁的构建发布操作了。

#### 3.允许单个团队做出技术决策

因为微前端构架与框架无关，当一个应用由多个团队进行开发时，每个团队都可以使用自己擅长的技术栈进行开发，也就是它允许适当的让团队决策使用哪种技术，从而使团队协作变得不再僵硬。

#### 微前端的使用场景：
- 拆分巨型应用，使应用变得更加可维护
- 兼容历史应用，实现增量开发

### 如何实现微前端

#### 1.多个微应用如何进行组合 ?

在微前端架构中，除了存在多个微应用以外，还存在一个容器应用，每个微应用都需要被注册到容器应用中。微前端中的每个应用在浏览器中都是一个独立的 JavaScript 模块，通过模块化的方式被容器应用启动和运行。使用模块化的方式运行应用可以防止不同的微应用在同时运行时发生冲突。

#### 2.在微应用中如何实现路由 ？

在微前端架构中，当路由发生变化时，容器应用首先会拦截路由的变化，根据路由匹配微前端应用，当匹配到微应用以后，再启动微应用路由，匹配具体的页面组件。

#### 3.微应用与微应用之间如何实现状态共享 ?

在微应用中可以通过发布订阅模式实现状态共享，比如使用 RxJS。

#### 4.微应用与微应用之间如何实现框架和库的共享？

通过 import-map 和 webpack 中的 externals 属性。

### Systemjs 模块化解决方案

在微前端架构中，微应用被打包为模块，但浏览器不支持模块化，需要使用 systemjs 实现浏览器中的模块化。

systemjs 是一个用于实现模块化的 JavaScript 库，有属于自己的模块化规范。

在开发阶段我们可以使用 ES 模块规范，然后使用 webpack 将其转换为 systemjs 支持的模块。

###  微前端框架 single-spa

single-spa 是一个实现微前端架构的框架。

#### 在 single-spa 框架中有三种类型的微前端应用：

- single-spa-application / parcel：微前端架构中的微应用，可以使用 vue、react、angular 等框架。
- single-spa root config：创建微前端容器应用。
- utility modules：公共模块应用，非渲染组件，用于跨应用共享 javascript 逻辑的微应用。

#### 创建容器应用

1.安装 single-spa 脚手架工具： npm install create-single-spa@4.1.2  

(这里可能有坑，容器应用里的webpack-config-single-spa 我是重新安装 4.0.0版本 )

2.创建微前端应用目录： mkdir workspace && cd "$_"

3.创建微前端容器应用： 输入命令 create-single-spa

然后会出现提示问题让你选择

![image](https://user-images.githubusercontent.com/37037802/144545905-a5fc183d-7450-4cbd-9628-d4d9fb3caf41.png)

  - 应用文件夹填写 container
  - 应用选择 single-spa root config // 这个代表容器应用
  - 组织名称填写 lwl，组织名称可以理解为团队名称，微前端架构允许多团队共同开发应用，组织名称可以标识应用，由哪个团队开发
  - 启动应用： npm start
  - 访问应用： localhost:9000
  - 默认代码解析
  
  容器应用配置文件 Root-config.js，用于注册和启动微应用
  /Root-config.js
  ```
  // workspace/container/src/study-root-config.js
  import { registerApplication, start } from "single-spa";
  /*
  注册微前端应用
  1. name: 字符串类型, 微前端应用名称 "@组织名称/应用名称"
  2. app: 函数类型, 返回 Promise, 通过 systemjs 引用打包好的微前端应用模块代码(umd)
  3. activeWhen: 路由匹配时激活应用
  */
  registerApplication({
      name: "@single-spa/welcome",
      app: () => System.import("https://unpkg.com/single-spa-welcome/dist/single-spa-welcome.js"),
      activeWhen: ["/"]
  });
  
  // start 方法必须在 single spa 的配置文件中调用
  // 在调用 start 之前, 应用会被加载, 但不会初始化, 挂载或卸载.
  start({
      // 是否可以通过 history.pushState() 和 history.replaceState() 更改触发
      single-spa 路由
      // true 不允许 false 允许
      urlRerouteOnly: true
  })
  ```
  
  /index.ejs
  ```
  // 定义模块名，下面需要用到
  <script type="systemjs-importmap">
    {
      "imports": {
        "@lwl/root-config": "//localhost:9000/lwl-root-config.js"
      }
    }
  </script>
  
  //导入容器应用 这里的@lwl/root-config模块就是刚刚上面定义的 //localhost:9000/lwl-root-config.js
  <script>
    System.import("@study/root-config")
  </script>
  
  //预加载single-spa模块，可提高性能
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/single-spa@5.9.0/lib/system/single-spa.min.js" as="script">
  
  <!--
import-map-overrides 可以覆盖导入映射
当前项目中用于配合 single-spa Inspector （需要先安装）调试工具使用.
可以手动覆盖项目中的 JavaScript 模块加载地址, 用于调试.
-->
<import-map-overrides-full show-when-local-storage="devtools" dev-libs>
</import-map-overrides-full>

  ```

4.创建基于Vue框架的微应用

- 输入命令 npx create-single-spa，选择 single-spa application / parcel -> vue -> vue2

![image](https://user-images.githubusercontent.com/37037802/144824491-c11b06e3-01f7-4586-a11a-b0e5bbae3527.png)

![image](https://user-images.githubusercontent.com/37037802/144825248-a9fe239e-2af4-49d7-b8d1-963d83568901.png)
  
- 创建完成后会生成相应目录
 
 ![image](https://user-images.githubusercontent.com/37037802/144825958-939c9142-e00b-40e8-9700-fbc2928a0a3d.png)
 
- 把Vue和Vue-router设置为公共模块，避免Webpack每次都把Vue和Vue-router打包
    - 新建vue.config.js文件（Vue-cli下进行webpack配置的方式），进行如下配置
    ```
    module.exports = {
      chainWebpack: config => {
        config.externals(["vue", "vue-router"]);
      }
    };

    ```
    
- 在容器应用下配置vue, vue-router的地址
  - /index.ejs 
  ```
  <script type="systemjs-importmap">
    {
      "imports": {
        "single-spa": "https://cdn.jsdelivr.net/npm/single-spa@5.9.0/lib/system/single-spa.min.js",
        "vue": "https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js",
        "vue-router": "https://cdn.jsdelivr.net/npm/vue-router@3.0.7/dist/vue-router.min.js"
      }
    }
  </script>
  ```

    
    
待更新...


