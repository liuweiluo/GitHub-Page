
## 柯里化与函数组合

### 柯里化 (Currying)

#### 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变），然后返回一个新的函数接收剩余的参数，返回结果

 使用柯里化解决硬编码的问题
```
function checkAge (age) {
let min = 18
return age >= min
}
// 普通纯函数
function checkAge (min, age) {
return age >= min
}
checkAge(18, 24)
checkAge(18, 20)
checkAge(20, 30)
// 柯里化
function checkAge (min) {
return function (age) {
return age >= min
}
}
// ES6 写法
let checkAge = min => (age => age >= min)
let checkAge18 = checkAge(18)
let checkAge20 = checkAge(20)
checkAge18(24)
checkAge18(20)
```

#### lodash 中的柯里化函数

#### _.curry(func)

功能：创建一个函数，该函数接收一个或多个 func 的参数，如果 func 所需要的参数都被提
供则执行 func 并返回执行的结果。否则继续返回该函数并等待接收剩余的参数。

参数：需要柯里化的函数

返回值：柯里化后的函数

```
const _ = require('lodash')
// 要柯里化的函数
function getSum (a, b, c) {
return a + b + c
}
// 柯里化后的函数
let curried = _.curry(getSum)
// 测试
curried(1, 2, 3)
curried(1)(2)(3)
curried(1, 2)(3)
```

案例
```
const _ = require('lodash')
const match = _.curry(function (reg, str) {
return str.match(reg)
})
const haveSpace = match(/\s+/g)
const haveNumber = match(/\d+/g)
console.log(haveSpace('hello world'))
console.log(haveNumber('25$'))
const filter = _.curry(function (func, array) {
return array.filter(func)
})
console.log(filter(haveSpace, ['John Connor', 'John_Donne']))
const findSpace = filter(haveSpace)
console.log(findSpace(['John Connor', 'John_Donne']))

```

模拟 _.curry() 的实现
```
function curry (func) {
return function curriedFn (...args) {
// 判断实参和形参的个数
if (args.length < func.length) {
return function () {
return curriedFn(...args.concat(Array.from(arguments)))
}
}
// 实参和形参个数相同，调用 func，返回结果
return func(...args)
}
}
```

#### 总结
> 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数
> 
> 这是一种对函数参数的'缓存'
> 
> 让函数变的更灵活，让函数的粒度更小
> 
> 可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能


### 函数组合

背景: 纯函数和柯里化很容易写出洋葱代码 h(g(f(x)))，函数组合可以让我们把细粒度的函数重新组合生成一个新的函数

#### 管道

下面这张图表示程序中使用函数处理数据的过程，给 fn 函数输入参数 a，返回结果 b。可以想想 a 数据
通过一个管道得到了 b 数据。

![image](https://user-images.githubusercontent.com/37037802/125786538-ab89fccd-c8de-4bb9-af7d-16acfd6d5c3a.png)

当 fn 函数比较复杂的时候，我们可以把函数 fn 拆分成多个小函数，此时多了中间运算过程产生的 m 和
n。

下面这张图中可以想象成把 fn 这个管道拆分成了3个管道 f1, f2, f3，数据 a 通过管道 f3 得到结果 m，m
再通过管道 f2 得到结果 n，n 通过管道 f1 得到最终结果 b

![image](https://user-images.githubusercontent.com/37037802/125786736-7d88a770-31b8-40b4-acfc-8eb55b2f4117.png)

```
fn = compose(f1, f2, f3)
b = fn(a)
```

#### 函数组合 (compose)：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数

函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果

函数组合默认是从右到左执行

```
// 组合函数
function compose (f, g) {
return function (x) {
return f(g(x))
}
}
function first (arr) {
return arr[0]
}
function reverse (arr) {
return arr.reverse()
}
// 从右到左运行
let last = compose(first, reverse)
console.log(last([1, 2, 3, 4]))
```

#### lodash 中的组合函数
> lodash 中组合函数 flow() 或者 flowRight()，他们都可以组合多个函数
> flow() 是从左到右运行
> flowRight() 是从右到左运行，使用的更多一些

```
const _ = require('lodash')
const toUpper = s => s.toUpperCase()
const reverse = arr => arr.reverse()
const first = arr => arr[0]
const f = _.flowRight(toUpper, first, reverse)
console.log(f(['one', 'two', 'three']))

```

模拟实现 lodash 的 flowRight 方法
```
// 多函数组合
function compose (...fns) {
return function (value) {
return fns.reverse().reduce(function (acc, fn) {
return fn(acc)
}, value)
}
}
// ES6
const compose = (...fns) => value => fns.reverse().reduce((acc, fn) =>
fn(acc), value)
```

#### 如何调试组合函数

```
const f = _.flowRight(_.toUpper, _.first, _.reverse)
console.log(f(['one', 'two', 'three']))

const _ = require('lodash')
const trace = _.curry((tag, v) => {
console.log(tag, v)
return v
})
const split = _.curry((sep, str) => _.split(str, sep))
const join = _.curry((sep, array) => _.join(array, sep))
const map = _.curry((fn, array) => _.map(array, fn))
const f = _.flowRight(join('-'), trace('map 之后'), map(_.toLower),
trace('split 之后'), split(' '))
console.log(f('NEVER SAY DIE'))
```

#### lodash/fp
> lodash 的 fp 模块提供了实用的对函数式编程友好的方法
> 提供了不可变 auto-curried iteratee-first data-last 的方法

```
// lodash 模块
const _ = require('lodash')
_.map(['a', 'b', 'c'], _.toUpper)
// => ['A', 'B', 'C']
_.map(['a', 'b', 'c'])
// => ['a', 'b', 'c']
_.split('Hello World', ' ')
// lodash/fp 模块
const fp = require('lodash/fp')
fp.map(fp.toUpper, ['a', 'b', 'c'])
fp.map(fp.toUpper)(['a', 'b', 'c'])
fp.split(' ', 'Hello World')
fp.split(' ')('Hello World')

const fp = require('lodash/fp')
const f = fp.flowRight(fp.join('-'), fp.map(_.toLower), fp.split(' '))
console.log(f('NEVER SAY DIE'))
```

### Point Free
#### Point Free：我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。

> 不需要指明处理的数据
> 只需要合成运算过程
> 需要定义一些辅助的基本运算函数

```
const f = fp.flowRight(fp.join('-'), fp.map(_.toLower), fp.split(' '))
```

案例演示
```
// 非 Point Free 模式
// Hello World => hello_world
function f (word) {
return word.toLowerCase().replace(/\s+/g, '_');
}
// Point Free
const fp = require('lodash/fp')
const f = fp.flowRight(fp.replace(/\s+/g, '_'), fp.toLower)
console.log(f('Hello World'))
```

使用 Point Free 的模式，把单词中的首字母提取并转换成大写
```
const fp = require('lodash/fp')
const firstLetterToUpper = fp.flowRight(join('. '),
fp.map(fp.flowRight(fp.first, fp.toUpper)), split(' '))
console.log(firstLetterToUpper('world wild web'))
// => W. W. W
```

