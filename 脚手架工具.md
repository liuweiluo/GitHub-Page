### 脚手架工具

#### 概要
脚手架的本质作用：创建项目基础结构、提供项目规范和约定

#### 常见的脚手架工具
-create-react-app -> React项目

-vue-cli -> Vue.js项目

-angular-cli -> Angular项目

-Yeoman -> 最通用的脚手架工具

-Plop -> 创建项目中同类型的小型脚手架工具


#### 使用Yeoman创建Vue Generator案例
1.打开命令窗口输入 mkdir generator-zce-vue 创建新的generator目录

![image](https://user-images.githubusercontent.com/37037802/118615374-40618180-b7f3-11eb-84aa-5492a1c2436b.png)

2.进入新建的generator-zce-vue目录

![image](https://user-images.githubusercontent.com/37037802/118615957-d5fd1100-b7f3-11eb-965e-86e3fcff9bef.png)

3.通过yarn init方式去初始化package.json

![image](https://user-images.githubusercontent.com/37037802/118616507-591e6700-b7f4-11eb-8505-ef62fcdb0af6.png)

4.安装yeoman-generator依赖

![image](https://user-images.githubusercontent.com/37037802/118616930-b9ada400-b7f4-11eb-95c1-728a1a04af5c.png)

5.打开vs-code编辑器进入相应目录，在目录下新建一个路径为generators/app/index.js的入口文件

![image](https://user-images.githubusercontent.com/37037802/118618051-ced70280-b7f5-11eb-8671-e59c086cf743.png)

6.在入口文件进行相应操作

```markdown
//通过require方式，载入yeoman-generator依赖
const Generator = require('yeoman-generator')

//导出一个继承Generator的类型
module.exports = class extends Generator {
  //定义一个prompting方法用于以命令行方式询问用户问题（目前的项目只询问项目名称，有需要可自行添加）
  prompting () {
    return this.prompt([
      {
        type: 'input',
        name: 'name',
        message: 'Your project name',
        default: this.appname
      }
    ])
    .then(answers => {
      //then方法返回prompting的返回值，即用户输入的数据，然后把数据挂载到this上即便后续使用
      this.answers = answers
    })
  }
}
```
7.创建templates目录，把我们想要的结构拷贝至templates目录下作为模板

![image](https://user-images.githubusercontent.com/37037802/118623169-8e2db800-b7fa-11eb-973d-00e5e9610155.png)

8.把项目结构里可变的地方通过模板引擎语法替换成ejs的标记

![image](https://user-images.githubusercontent.com/37037802/118623966-52dfb900-b7fb-11eb-92a1-6ea082aa81e3.png)
![image](https://user-images.githubusercontent.com/37037802/118624041-625f0200-b7fb-11eb-854c-8e4cc138b989.png)

9.通过writing方法把模板下的结构生成至对应的目标路径

```markdown
//通过require方式，载入yeoman-generator依赖
const Generator = require('yeoman-generator')

//导出一个继承Generator的类型
module.exports = class extends Generator {
  //定义一个prompting方法用于以命令行方式询问用户问题（目前的项目只询问项目名称，有需要可自行添加）
  prompting () {
    return this.prompt([
      {
        type: 'input',
        name: 'name',
        message: 'Your project name',
        default: this.appname
      }
    ])
    .then(answers => {
      //then方法返回prompting的返回值，即用户输入的数据，然后把数据挂载到this上即便后续使用
      this.answers = answers
    })
  }

  writing () {
    // 把每一个文件都通过模板转换到目标路径

    const templates = [
      '.browserslistrc',
      '.editorconfig',
      '.env.development',
      '.env.production',
      '.eslintrc.js',
      '.gitignore',
      'babel.config.js',
      'package.json',
      'postcss.config.js',
      'README.md',
      'public/favicon.ico',
      'public/index.html',
      'src/App.vue',
      'src/main.js',
      'src/router.js',
      'src/assets/logo.png',
      'src/components/HelloWorld.vue',
      'src/store/actions.js',
      'src/store/getters.js',
      'src/store/index.js',
      'src/store/mutations.js',
      'src/store/state.js',
      'src/utils/request.js',
      'src/views/About.vue',
      'src/views/Home.vue'
    ]

    templates.forEach(item => {
      // item => 每个文件路径
      this.fs.copyTpl(
        this.templatePath(item),
        this.destinationPath(item),
        this.answers
      )
    })
  }
}
```

10.回到命令行，通过yarn link方式把generator-zce-vue模块作为全局模块

![image](https://user-images.githubusercontent.com/37037802/118625432-9850b600-b7fc-11eb-8014-7984cc3bb2b3.png)

11.然后我们定位一个全新的目录（这里为my-proj目录），通过Yeoman命令去运行我们刚刚创建的Generator

![image](https://user-images.githubusercontent.com/37037802/118626396-6db32d00-b7fd-11eb-8402-5d6d097ed962.png)

12.运行成功后，my-proj目录下就会生成相应结构

![image](https://user-images.githubusercontent.com/37037802/118626938-def2e000-b7fd-11eb-9181-f9e3426c2a98.png)


#### 通过node.js去开发脚手架工具

前言：脚手架工具其实是一个node的cli应用，创建脚手架就是去创建cli应用

1.打开命令行输入mkdir命令创建项目目录(这里为sample-scaffolding)

![image](https://user-images.githubusercontent.com/37037802/118748004-a00c6b00-b88d-11eb-83d3-15cfaf431b93.png)

2.进入目录，通过yarn init方式去初始化package.json文件

![image](https://user-images.githubusercontent.com/37037802/118748198-01ccd500-b88e-11eb-9cc6-9dbb11e4d85a.png)

3.打开vs-code编辑器进入相应目录，在package.json中添加bin字段，该字段用于指定cli应用的入口文件（这里新建的入口文件为cli.js）

![image](https://user-images.githubusercontent.com/37037802/118748821-fb8b2880-b88e-11eb-8710-8f23c400c022.png)

4.与普通node的js文件有所不同的是，cli应用的入口文件必需有特定的文件头

![image](https://user-images.githubusercontent.com/37037802/118749397-04c8c500-b890-11eb-8bd0-2b7114b5022b.png)

5.实现脚手架具体业务: 
  
  a.通过命令行交互询问用户问题
  
  b.根据用户回答问题的结果生成文件
  
6.在node当中发起命令行交互询问需要使用inquerer模块，安装inquerer模块

![image](https://user-images.githubusercontent.com/37037802/118750116-5c1b6500-b891-11eb-9a99-360d63be40ad.png)

7.载入inquirer模块，通过inquirer的prompt方法发起命令行询问，该方法接受一个数组参数

```markdown
#!/usr/bin/env node

// Node CLI 应用入口文件必须要有这样的文件头
// 如果是 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755
// 具体就是通过 chmod 755 cli.js 实现修改

// 脚手架的工作过程：
// 1. 通过命令行交互询问用户问题
// 2. 根据用户回答的结果生成文件

const inquirer = require('inquirer')

inquirer.prompt([
  {
    type: 'input',  //指定问题输入方式
    name: 'name',   //指定问题返回值的键
    message: 'Project name?' //指定给用户的提示
  }
]).then(anwsers=>{
   // 接受到用户的答案
   console.log(anwsers)
})
```

8.动态生成项目文件，生成项目文件一般根据模板去生成，所以在项目根目录下新建一个templates目录，在templates下新建模板（这里为index.html和style.css)

![image](https://user-images.githubusercontent.com/37037802/118751743-730f8680-b894-11eb-8bc8-c99a21c3f581.png)

![image](https://user-images.githubusercontent.com/37037802/118751764-7e62b200-b894-11eb-8dc4-1451ba1d94a9.png)

![image](https://user-images.githubusercontent.com/37037802/118751798-8c183780-b894-11eb-8745-73201a8be633.png)

9.根据用户回答结果生成文件，明确根目录与目标路径

```markdown
const inquirer = require('inquirer')
const path = require('path')

inquirer.prompt([
  {
    type: 'input',  //指定问题输入方式
    name: 'name',   //指定问题返回值的键
    message: 'Project name?' //指定给用户的提示
  }
]).then(anwsers=>{
   // 接受到用户的答案
   console.log(anwsers)
   
  // 模板目录
  const tmplDir = path.join(__dirname, 'templates')
  
  //输出的目标目录一般为命令行所在目录，即命令行在那个目录下执行，目标目录就在那个目录下 即是cwd目录
  //通过process.cwd方法得到cwd目录路径
  const destDir = process.cwd()
})
```

10.通过fs模块读取模板目录的文件，把这些文件全部输出到目标目录

```markdown
#!/usr/bin/env node

// Node CLI 应用入口文件必须要有这样的文件头
// 如果是 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755
// 具体就是通过 chmod 755 cli.js 实现修改

// 脚手架的工作过程：
// 1. 通过命令行交互询问用户问题
// 2. 根据用户回答的结果生成文件

const fs = require('fs')
const path = require('path')
const inquirer = require('inquirer')
const ejs = require('ejs')

inquirer.prompt([
  {
    type: 'input',
    name: 'name',
    message: 'Project name?'
  }
])
.then(anwsers => {
  // console.log(anwsers)
  // 根据用户回答的结果生成文件

  // 模板目录
  const tmplDir = path.join(__dirname, 'templates')
  //输出的目标目录一般为命令行所在目录，即命令行在那个目录下执行，目标目录就在那个目录下 即是cwd目录
  //通过process.cwd方法得到cwd目录路径
  // 目标目录
  const destDir = process.cwd()

  // 将模板下的文件全部转换到目标目录
  fs.readdir(tmplDir, (err, files) => {
    if (err) throw err
    files.forEach(file => {
      // 通过模板引擎渲染文件
      ejs.renderFile(path.join(tmplDir, file), anwsers, (err, result) => {
        if (err) throw err

        // 将结果写入目标文件路径
        fs.writeFileSync(path.join(destDir, file), result)
      })
    })
  })
})
```
11.把脚手架工具应用通过 yarn link 命令link至全局进行使用(执行yarn link 命令前需要对yarn进行环境变量配置)

12.定位新目录尝试使用脚手架，在新目录下输入sample-scaffolding

![image](https://user-images.githubusercontent.com/37037802/118754445-aaccfd00-b899-11eb-9195-c5969cea09b6.png)


